// shader: 8B31, F4B767110674F1C9

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn12();
bool Vfn17();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn2();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 133u;
while (true) {
switch (jmp_to) {
case 133u:
Vfn1();
tmp_reg0 = vs_in_reg1.xyyy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1 = vs_in_reg0.xyyy;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg13 = mul_s(vs_pica.f[12], vs_in_reg2);
vs_out_reg3.x = dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz);
vs_out_reg3.yz = vec2(dot_3(vs_pica.f[14].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[16].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, tmp_reg13);
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
Vfn1();
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg1);
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (vs_in_reg1).xyz;
vs_out_reg5.xy = (vs_pica.f[93].xxxx).xy;
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 494u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 500u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5.zw = (vs_pica.f[93].xxxx).zw;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 03835F9D5627179D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, E9CE7AFC482AF804
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 56DCF3B49F68D334, F4B767110674F1C9
// reference: 228A2A6E04DEF67B, 03835F9D5627179D
// reference: D76EA6EB04DEF67B, E9CE7AFC482AF804
// program: F4B767110674F1C9, 0000000000000000, 03835F9D5627179D
// program: F4B767110674F1C9, 0000000000000000, E9CE7AFC482AF804
// shader: 8B31, DEC4F585F5D29D43

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn6();
bool Vfn2();
bool Vfn3();
bool Vfn4();
bool Vfn0();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn2();
} else {
Vfn3();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn6() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn2();
} else {
Vfn3();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn2() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn3() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn4() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn0() {
uint jmp_to = 417u;
while (true) {
switch (jmp_to) {
case 417u:
Vfn1();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn4();
Vfn6();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
// shader: 8B30, D8AEBF8BFB000185
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, A7DFDB0325399CC8

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn8();
bool Vfn14();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn2();
bool Vfn1();
bool Vfn0();
bool Vfn12();
bool Vfn10();
bool Vfn11();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn8() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn14() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn1() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn0() {
uint jmp_to = 304u;
while (true) {
switch (jmp_to) {
case 304u:
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn1();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn1();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn8();
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn10();
} else {
Vfn11();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn12();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn8();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn14();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn8();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn8();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn8();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn10();
} else {
Vfn11();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn10() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn11() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, A3929105985CE196
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 0CDB2AE82F85AF04

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn6();
bool Vfn3();
bool Vfn4();
bool Vfn5();
bool Vfn1();
bool Vfn0();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn6() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn5() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn0() {
uint jmp_to = 432u;
while (true) {
switch (jmp_to) {
case 432u:
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn3();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
// shader: 8B30, 00688A2DC1229BAD
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(fma((combiner_buffer.rgb), (primary_fragment_color.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, AD8332D189CB4F32
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 66EB1EDF15560440
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(fma((combiner_buffer.rgb), (primary_fragment_color.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 96167D0382BE1967

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn6();
bool Vfn12();
bool Vfn17();
bool Vfn3();
bool Vfn4();
bool Vfn5();
bool Vfn1();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn6() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn5() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 148u;
while (true) {
switch (jmp_to) {
case 148u:
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn6();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg1);
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn6();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (vs_in_reg1).xyz;
vs_out_reg5.xy = (vs_pica.f[93].xxxx).xy;
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn6();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn3();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 494u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 500u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5.zw = (vs_pica.f[93].xxxx).zw;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 11B7D438BFF9AA08
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5C1E368F36789AE6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 8806B69C3202991A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((texcolor1.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 0E8203CAEF38E823

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn12();
bool Vfn17();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn2();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 165u;
while (true) {
switch (jmp_to) {
case 165u:
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (vs_in_reg1).xyz;
vs_out_reg5.xy = (vs_pica.f[93].xxxx).xy;
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 500u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5.zw = (vs_pica.f[93].xxxx).zw;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 573BCB23558CC9FD
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 237AFA30659650BF
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 17CBD27F1AD6539A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 9B3DCCEC429F47F0
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (const_color[2].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp(fma((texcolor2.a), (const_color[2].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) * (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 8601642ADE02A482
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (const_color[2].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp(fma((texcolor2.a), (const_color[2].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (last_tev_out.aaa), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((last_tev_out.rgb), (combiner_buffer.rgb), (rounded_primary_color.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 39633EA4FDF0DD5B
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (vec3(1) - last_tev_out.rgb);
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (const_color[2].a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 56DCF3B4664FE0D6, DEC4F585F5D29D43
// reference: 2296EDF60AE0B868, D8AEBF8BFB000185
// reference: 56DCF3B471056D60, A7DFDB0325399CC8
// reference: 6724F19B6BB1BAF1, A3929105985CE196
// reference: 56DCF3B4461B25F8, 0CDB2AE82F85AF04
// reference: C356D89905CA721F, 00688A2DC1229BAD
// reference: 7C4B705E872B8599, AD8332D189CB4F32
// reference: D839595CE9504D77, 66EB1EDF15560440
// reference: 56DCF3B4BF3C161A, 96167D0382BE1967
// reference: F45589538B7D1ACD, 11B7D438BFF9AA08
// reference: B651560D29B87B87, 5C1E368F36789AE6
// reference: A48D36CF1457289C, 8806B69C3202991A
// reference: 56DCF3B492AF4112, 0E8203CAEF38E823
// reference: EE9019C227863594, 573BCB23558CC9FD
// reference: BBE6BF0427863594, 237AFA30659650BF
// reference: B28DFB06536AD23F, 17CBD27F1AD6539A
// reference: 1201AE321779F5F0, 9B3DCCEC429F47F0
// reference: 33203949A0981651, 8601642ADE02A482
// reference: 48A0B921123DC11C, 39633EA4FDF0DD5B
// program: DEC4F585F5D29D43, 0000000000000000, D8AEBF8BFB000185
// program: A7DFDB0325399CC8, 0000000000000000, A3929105985CE196
// program: 0CDB2AE82F85AF04, 0000000000000000, 00688A2DC1229BAD
// program: A7DFDB0325399CC8, 0000000000000000, AD8332D189CB4F32
// program: 0CDB2AE82F85AF04, 0000000000000000, 66EB1EDF15560440
// program: 96167D0382BE1967, 0000000000000000, 11B7D438BFF9AA08
// program: DEC4F585F5D29D43, 0000000000000000, 5C1E368F36789AE6
// program: DEC4F585F5D29D43, 0000000000000000, 8806B69C3202991A
// program: 0E8203CAEF38E823, 0000000000000000, 573BCB23558CC9FD
// program: 0E8203CAEF38E823, 0000000000000000, 237AFA30659650BF
// program: 0E8203CAEF38E823, 0000000000000000, 17CBD27F1AD6539A
// program: 7133A79A5A04EAE5, 0000000000000000, 9B3DCCEC429F47F0
// program: 7133A79A5A04EAE5, 0000000000000000, 8601642ADE02A482
// program: F515C0C2B259CDB0, 0000000000000000, 39633EA4FDF0DD5B
// shader: 8B30, 0B9FB18B40081B3D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, E1685ED15D11DF1F

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn10();
bool Vfn15();
bool Vfn5();
bool Vfn6();
bool Vfn7();
bool Vfn2();
bool Vfn4();
bool Vfn8();
bool Vfn1();
bool Vfn0();
bool Vfn13();
bool Vfn11();
bool Vfn12();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn10() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn15() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn6() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn7() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn4() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn8() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn5();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn1() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
Vfn5();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn0() {
uint jmp_to = 295u;
while (true) {
switch (jmp_to) {
case 295u:
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn1();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn13();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn13();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn5();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn13() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn11() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn12() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 94BE77823894CED6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[0][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(view.xyz)), 0.0));
specular_sum.a = lut_scale_fr * lut_value;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (const_color[1].rgb)), vec3(0), vec3(1)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_2 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (last_tev_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor0.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: ACCBD2F5EB29551B, 0B9FB18B40081B3D
// reference: D86F82648B7D1ACD, 11B7D438BFF9AA08
// reference: 56DCF3B486E380C0, E1685ED15D11DF1F
// reference: BC4A54C554E1FF68, 94BE77823894CED6
// reference: 0FF00FE88B7D1ACD, 11B7D438BFF9AA08
// reference: 404339BF27863594, 237AFA30659650BF
// program: A7DFDB0325399CC8, 0000000000000000, 0B9FB18B40081B3D
// program: E1685ED15D11DF1F, 0000000000000000, 94BE77823894CED6
// shader: 8B30, FEE59432B21903E7
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, BACCCA81D005BEB6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (rounded_primary_color.ggg), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (rounded_primary_color.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (rounded_primary_color.bbb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 949E7EF151D40B95
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 8E2E079812B4659D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 596C8D8101BD5489, FEE59432B21903E7
// reference: 905436CFAF08C1F1, BACCCA81D005BEB6
// reference: B64D919527863594, 949E7EF151D40B95
// reference: 43A91D1027863594, 8E2E079812B4659D
// program: F515C0C2B259CDB0, 0000000000000000, FEE59432B21903E7
// program: F515C0C2B259CDB0, 0000000000000000, BACCCA81D005BEB6
// program: F4B767110674F1C9, 0000000000000000, 949E7EF151D40B95
// program: F4B767110674F1C9, 0000000000000000, 8E2E079812B4659D
// shader: 8B30, 8CC7FC6389010AC6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (vec3(1) - last_tev_out.rgb);
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (const_color[2].a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: DC6702DA316502F3, 8CC7FC6389010AC6
// program: F515C0C2B259CDB0, 0000000000000000, 8CC7FC6389010AC6
// shader: 8B31, AEA50A5BCE37F791

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn10();
bool Vfn15();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn1();
bool Vfn3();
bool Vfn7();
bool Vfn0();
bool Vfn9();
bool Vfn8();
bool Vfn13();
bool Vfn11();
bool Vfn12();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn10() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn15() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn3() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn7() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 223u;
while (true) {
switch (jmp_to) {
case 223u:
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn3();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn7();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn8();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn9();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn9();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn13();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn13();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn9() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn7();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn8() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn13() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn11() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn12() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 0F4CF04D42978E33
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 6E0865F19FA8EB0E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn10();
bool Vfn15();
bool Vfn3();
bool Vfn4();
bool Vfn5();
bool Vfn1();
bool Vfn7();
bool Vfn6();
bool Vfn0();
bool Vfn9();
bool Vfn8();
bool Vfn13();
bool Vfn11();
bool Vfn12();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn10() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn15() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn5() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn6() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 239u;
while (true) {
switch (jmp_to) {
case 239u:
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn6();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn8();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn9();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn9();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn13();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn13();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn3();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn9() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn6();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn8() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn13() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn11() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn12() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, F62DC5C624D01780
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B2B8E88FE49125AC
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5CFDA1FA1B6F77DE
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, C36C84E0FD00013F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B9BCB590AAB29687
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (rounded_primary_color.ggg), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (rounded_primary_color.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (rounded_primary_color.bbb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 301AC0596414B120
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, A7E8681B88D4CF33
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 1A4F97107F3846B4

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn6();
bool Vfn2();
bool Vfn9();
bool Vfn3();
bool Vfn4();
bool Vfn7();
bool Vfn0();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn6() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn3();
} else {
Vfn4();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn2() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn3();
} else {
Vfn4();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn9() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn3();
} else {
Vfn4();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn4() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn7() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn0() {
uint jmp_to = 400u;
while (true) {
switch (jmp_to) {
case 400u:
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn2();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn6();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn7();
Vfn9();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
// shader: 8B30, 33B56787C2BD9AD1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, D114903C442D4F8E
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 6C2653B3E1A8C2B7

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn0();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
} else {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn0() {
uint jmp_to = 450u;
while (true) {
switch (jmp_to) {
case 450u:
Vfn1();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
// shader: 8B30, 2701EF51B30C5318
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((texcolor1.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (texcolor2.rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (texcolor2.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, E7F18C917D737F81
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[0][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(view.xyz)), 0.0));
specular_sum.a = lut_scale_fr * lut_value;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (const_color[1].rgb)), vec3(0), vec3(1)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_2 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (last_tev_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor0.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, E4CCF1A640E89D4B

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
vec4 vs_out_reg4;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn0();
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
} else {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn0() {
uint jmp_to = 466u;
while (true) {
switch (jmp_to) {
case 466u:
Vfn1();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
// shader: 8B30, 8F4CE7744B27FDD8
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 6985C9804885EC91
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 56DCF3B421A341B8, AEA50A5BCE37F791
// reference: A600794D441935C8, 0F4CF04D42978E33
// reference: 56DCF3B42A871A8D, 6E0865F19FA8EB0E
// reference: 28B828A83B13CA2C, F62DC5C624D01780
// reference: 1D93C149441935C8, B2B8E88FE49125AC
// reference: 9919926A04DEF67B, 5CFDA1FA1B6F77DE
// reference: 76388E7E22E59766, C36C84E0FD00013F
// reference: BF0035308C50021E, B9BCB590AAB29687
// reference: 6CFD1EEF04DEF67B, 301AC0596414B120
// reference: ACCBD2F587CAC8E2, A7E8681B88D4CF33
// reference: 56DCF3B44BDCB7DE, 1A4F97107F3846B4
// reference: 1AE89BD1A977030C, 33B56787C2BD9AD1
// reference: 8C6496851271725E, D114903C442D4F8E
// reference: 56DCF3B41BDE42FB, 6C2653B3E1A8C2B7
// reference: B2B7D10FD6F1270E, 2701EF51B30C5318
// reference: BC4A54C538026291, E7F18C917D737F81
// reference: 56DCF3B41D3D8BE8, E4CCF1A640E89D4B
// reference: B458991E337314B5, 8F4CE7744B27FDD8
// reference: 512A762727863594, 6985C9804885EC91
// program: AEA50A5BCE37F791, 0000000000000000, 0F4CF04D42978E33
// program: 6E0865F19FA8EB0E, 0000000000000000, F62DC5C624D01780
// program: AEA50A5BCE37F791, 0000000000000000, B2B8E88FE49125AC
// program: F4B767110674F1C9, 0000000000000000, 5CFDA1FA1B6F77DE
// program: F515C0C2B259CDB0, 0000000000000000, C36C84E0FD00013F
// program: F515C0C2B259CDB0, 0000000000000000, B9BCB590AAB29687
// program: F4B767110674F1C9, 0000000000000000, 301AC0596414B120
// program: A7DFDB0325399CC8, 0000000000000000, A7E8681B88D4CF33
// program: 1A4F97107F3846B4, 0000000000000000, 33B56787C2BD9AD1
// program: 1A4F97107F3846B4, 0000000000000000, D114903C442D4F8E
// program: 6C2653B3E1A8C2B7, 0000000000000000, 2701EF51B30C5318
// program: E1685ED15D11DF1F, 0000000000000000, E7F18C917D737F81
// program: E4CCF1A640E89D4B, 0000000000000000, 8F4CE7744B27FDD8
// program: 0E8203CAEF38E823, 0000000000000000, 6985C9804885EC91
// shader: 8B30, 36466AC4C97B7713
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 1DECB6567923A153
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (const_color[1].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (const_color[1].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[3].rgb), (const_color[3].aaa)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = (combiner_buffer.rgb);
float alpha_output_5 = ByteRound(clamp((last_tev_out.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 72AE5B0A337314B5, 36466AC4C97B7713
// reference: 97DCB43327863594, 237AFA30659650BF
// reference: C2A830243EA4CAA5, 1DECB6567923A153
// program: E4CCF1A640E89D4B, 0000000000000000, 36466AC4C97B7713
// program: DEC4F585F5D29D43, 0000000000000000, 1DECB6567923A153
// shader: 8B30, 8383A1ADD1548CFB
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 3E4469F77B04B771
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 8B8D18415A8569F1

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn6();
bool Vfn12();
bool Vfn17();
bool Vfn3();
bool Vfn4();
bool Vfn5();
bool Vfn1();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn6() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn5() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 177u;
while (true) {
switch (jmp_to) {
case 177u:
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn6();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn3();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 6DF7980F844EA1EE
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, A10A77541D1A2A9C
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((texcolor1.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 6A6EC84316D34501
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 1AE89BD14585FFC4, 8383A1ADD1548CFB
// reference: ACCBD2F56B38342A, 3E4469F77B04B771
// reference: 56DCF3B40E90B8F5, 8B8D18415A8569F1
// reference: F8EFBDEC01BD5489, 6DF7980F844EA1EE
// reference: 304A8D34370FEB73, A10A77541D1A2A9C
// reference: 5E94503DDF81E87D, 6A6EC84316D34501
// program: 1A4F97107F3846B4, 0000000000000000, 8383A1ADD1548CFB
// program: A7DFDB0325399CC8, 0000000000000000, 3E4469F77B04B771
// program: 8B8D18415A8569F1, 0000000000000000, 6DF7980F844EA1EE
// program: 0CDB2AE82F85AF04, 0000000000000000, A10A77541D1A2A9C
// program: 0CDB2AE82F85AF04, 0000000000000000, D8AEBF8BFB000185
// program: E4CCF1A640E89D4B, 0000000000000000, 6A6EC84316D34501
// shader: 8B30, 80A8E2D974B25045
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B154A05ED8B52911
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 58413225536AD23F, 80A8E2D974B25045
// reference: 9EB7F031536AD23F, B154A05ED8B52911
// program: 0E8203CAEF38E823, 0000000000000000, 80A8E2D974B25045
// program: 0E8203CAEF38E823, 0000000000000000, B154A05ED8B52911
// shader: 8B30, B201769980A22BA1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 3CA5832F68FEAA3F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 64EFC56CE5276601
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 837A301C2614D307
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 99F2392E777BFD23, B201769980A22BA1
// reference: 174A68CB087102C7, 3CA5832F68FEAA3F
// reference: 2261812A777BFD23, 64EFC56CE5276601
// reference: 398BB82904DEF67B, 837A301C2614D307
// program: AEA50A5BCE37F791, 0000000000000000, B201769980A22BA1
// program: 6E0865F19FA8EB0E, 0000000000000000, 3CA5832F68FEAA3F
// program: AEA50A5BCE37F791, 0000000000000000, 64EFC56CE5276601
// program: 0E8203CAEF38E823, 0000000000000000, 837A301C2614D307
// shader: 8B30, EAB00C117E590224
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, CCB4239DD0225726
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5939B9C742908284
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, DDCB52C625FD5337
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = (last_tev_out.rgb);
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, BD09DF4B71A9B76E
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 432192F868DD3EA4
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, DBA7C834B3E957DA
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, E9B93E0E5F120E63
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 40065C472AE4DC56
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, A8E6D818FBEA9D8D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, D3E02C8B6CB27652
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (last_tev_out.rgb);
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 41ABB5A941FD1096
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 882FDC12D1EA1C5D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, A42E681D53AB8B60
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (rounded_primary_color.ggg), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (rounded_primary_color.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (rounded_primary_color.bbb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 3D731496337038BF, EAB00C117E590224
// reference: B3CB45734C7AC75B, CCB4239DD0225726
// reference: 86E0AC92337038BF, 5939B9C742908284
// reference: 145F0C273D56A35A, DDCB52C625FD5337
// reference: 56B8B1F622E59766, BD09DF4B71A9B76E
// reference: 58050E27C4772F9C, 432192F868DD3EA4
// reference: 566DA90E04DEF67B, DBA7C834B3E957DA
// reference: 6C28061722E59766, E9B93E0E5F120E63
// reference: 031B0FC804DEF67B, 40065C472AE4DC56
// reference: 3B5B2C0584B1BA57, A8E6D818FBEA9D8D
// reference: 2ECFBBC63D56A35A, D3E02C8B6CB27652
// reference: A389258B04DEF67B, 41ABB5A941FD1096
// reference: 4CA8399F22E59766, 882FDC12D1EA1C5D
// reference: 859082D18C50021E, A42E681D53AB8B60
// program: AEA50A5BCE37F791, 0000000000000000, EAB00C117E590224
// program: 6E0865F19FA8EB0E, 0000000000000000, CCB4239DD0225726
// program: AEA50A5BCE37F791, 0000000000000000, 5939B9C742908284
// program: F4B767110674F1C9, 0000000000000000, DDCB52C625FD5337
// program: 0E8203CAEF38E823, 0000000000000000, 301AC0596414B120
// program: 8B8D18415A8569F1, 0000000000000000, BD09DF4B71A9B76E
// program: A7DFDB0325399CC8, 0000000000000000, 432192F868DD3EA4
// program: 0E8203CAEF38E823, 0000000000000000, DBA7C834B3E957DA
// program: 8B8D18415A8569F1, 0000000000000000, E9B93E0E5F120E63
// program: 0E8203CAEF38E823, 0000000000000000, 40065C472AE4DC56
// program: A7DFDB0325399CC8, 0000000000000000, A8E6D818FBEA9D8D
// program: F4B767110674F1C9, 0000000000000000, D3E02C8B6CB27652
// program: F4B767110674F1C9, 0000000000000000, 41ABB5A941FD1096
// program: F515C0C2B259CDB0, 0000000000000000, 882FDC12D1EA1C5D
// program: F515C0C2B259CDB0, 0000000000000000, A42E681D53AB8B60
// program: F4B767110674F1C9, 0000000000000000, DBA7C834B3E957DA
// shader: 8B30, 0686541C97959BF4
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B78C5BC438CEBBC2
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[0][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(view.xyz)), 0.0));
specular_sum.a = lut_scale_fr * lut_value;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((rounded_primary_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (const_color[1].rgb)), vec3(0), vec3(1)));
float alpha_output_1 = (secondary_fragment_color.a);
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_2 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor0.rgb), (last_tev_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 4.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) + (combiner_buffer.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor0.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B4170363C2A69641
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, FA216DC09B27D131
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (rounded_primary_color.ggg), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (rounded_primary_color.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (rounded_primary_color.bbb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 58050E274ABC5FA3, 0686541C97959BF4
// reference: 48848817F574F5D0, B78C5BC438CEBBC2
// reference: 9B37B413A825D922, B4170363C2A69641
// reference: D484824404DEF67B, 40065C472AE4DC56
// reference: 81F2248204DEF67B, DBA7C834B3E957DA
// reference: F950364A3D56A35A, D3E02C8B6CB27652
// reference: 7416A80704DEF67B, 41ABB5A941FD1096
// reference: 9B37B41322E59766, 882FDC12D1EA1C5D
// reference: 520F0F5D8C50021E, FA216DC09B27D131
// program: A7DFDB0325399CC8, 0000000000000000, 0686541C97959BF4
// program: E1685ED15D11DF1F, 0000000000000000, B78C5BC438CEBBC2
// program: 96167D0382BE1967, 0000000000000000, B4170363C2A69641
// program: F515C0C2B259CDB0, 0000000000000000, FA216DC09B27D131
// shader: 8B30, CA2BAF566CF4488C
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 597712470F798569
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 978759A613A19FEE
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B3CC80C0FEA5B140
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 556E6CE478302A33
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = (last_tev_out.rgb);
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 9B4E66B7A24A26D1

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn11();
bool Vfn16();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn1();
bool Vfn3();
bool Vfn8();
bool Vfn0();
bool Vfn10();
bool Vfn9();
bool Vfn14();
bool Vfn12();
bool Vfn13();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn11() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn16() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn3() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn8() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 187u;
while (true) {
switch (jmp_to) {
case 187u:
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn3();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn3();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn8();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn9();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn9();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn11();
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn12();
} else {
Vfn13();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn14();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn14();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn11();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn16();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn11();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn11();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn11();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn8();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn9() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn14() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn12();
} else {
Vfn13();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn12() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn13() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 9821B335B3F83611
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 3715214F1E53CF8A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((const_color[0].rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, FB0C4ECF15CBE1EB

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn12();
bool Vfn17();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn2();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 121u;
while (true) {
switch (jmp_to) {
case 121u:
tmp_reg12 = mul_s(vs_pica.f[16], vs_in_reg0.xyxy);
tmp_reg12 = vs_pica.f[13] + tmp_reg12;
vs_out_reg2 = vs_pica.f[12];
tmp_reg14 = mul_s(vs_pica.f[15], vs_in_reg1);
tmp_reg13 = vs_pica.f[93].yyyy + tmp_reg12.zwww;
tmp_reg13 = mul_s(vs_pica.f[95].zzzz, tmp_reg13);
tmp_reg14.y = (vs_pica.f[14].wwww + tmp_reg14).y;
tmp_reg13 = mul_s(vs_pica.f[14], tmp_reg13);
vs_out_reg0.xy = (tmp_reg12.xyyy).xy;
vs_out_reg0.zw = (vs_pica.f[93].xxxy).zw;
vs_out_reg3.xyz = (tmp_reg13 + tmp_reg14).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn1();
tmp_reg0 = vs_in_reg1.xyyy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1 = vs_in_reg0.xyyy;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg13 = mul_s(vs_pica.f[12], vs_in_reg2);
vs_out_reg3.x = dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz);
vs_out_reg3.yz = vec2(dot_3(vs_pica.f[14].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[16].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, tmp_reg13);
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
Vfn1();
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg1);
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (vs_in_reg1).xyz;
vs_out_reg5.xy = (vs_pica.f[93].xxxx).xy;
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 494u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 500u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5.zw = (vs_pica.f[93].xxxx).zw;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, AE76B7E946C731E7
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((vec3(1) - texcolor0.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
vec3 color_output_1 = ByteRound(clamp(fma((vec3(1) - last_tev_out.rgb), (const_color[1].rrr), (const_color[1].ggg)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((last_tev_out.a), (const_color[1].a), (const_color[1].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[2].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_2 = 0.0;
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (const_color[3].a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(mix((last_tev_out.rgb), (vec3(1) - combiner_buffer.rgb), (rounded_primary_color.bbb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(mix((last_tev_out.a), (combiner_buffer.a), (rounded_primary_color.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (rounded_primary_color.rrr), (const_color[5].aaa)), vec3(0), vec3(1)));
float alpha_output_5 = (rounded_primary_color.g);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5A210ADDE9385C60
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rrr), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
vec3 color_output_1 = ByteRound(clamp(fma((texcolor1.rgb), (rounded_primary_color.ggg), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(fma((texcolor1.a), (rounded_primary_color.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((texcolor2.rgb), (rounded_primary_color.bbb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = (const_color[2].a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 8E3749C5CA581F50
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: ACBF4EDCC5949EF5, CA2BAF566CF4488C
// reference: 1A9C07F8EB29551B, 597712470F798569
// reference: CA68397AA9964E77, 978759A613A19FEE
// reference: 64D83BB5339259CE, B3CC80C0FEA5B140
// reference: E1BB80A23D56A35A, 556E6CE478302A33
// reference: 56DCF3B4AD37C726, 9B4E66B7A24A26D1
// reference: 0A0797B6F447B054, 9821B335B3F83611
// reference: 6CFD1EEF691C102F, 3715214F1E53CF8A
// reference: 56DCF3B4CCC8B388, FB0C4ECF15CBE1EB
// reference: 2E56AA2A35FABF6E, AE76B7E946C731E7
// reference: 79F6F724CFD77CC1, 5A210ADDE9385C60
// reference: 59A8453814074136, 8E3749C5CA581F50
// program: 1A4F97107F3846B4, 0000000000000000, CA2BAF566CF4488C
// program: A7DFDB0325399CC8, 0000000000000000, 597712470F798569
// program: 1A4F97107F3846B4, 0000000000000000, 978759A613A19FEE
// program: E4CCF1A640E89D4B, 0000000000000000, B3CC80C0FEA5B140
// program: F4B767110674F1C9, 0000000000000000, 556E6CE478302A33
// program: 9B4E66B7A24A26D1, 0000000000000000, 9821B335B3F83611
// program: 9B4E66B7A24A26D1, 0000000000000000, 3715214F1E53CF8A
// program: FB0C4ECF15CBE1EB, 0000000000000000, AE76B7E946C731E7
// program: F515C0C2B259CDB0, 0000000000000000, 5A210ADDE9385C60
// program: 0E8203CAEF38E823, 0000000000000000, 8E3749C5CA581F50
// shader: 8B30, BEF07C09C2BD13FB
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: A22EF9A1339259CE, BEF07C09C2BD13FB
// program: E4CCF1A640E89D4B, 0000000000000000, BEF07C09C2BD13FB
// shader: 8B31, B76F238318D8A515

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn10();
bool Vfn15();
bool Vfn5();
bool Vfn6();
bool Vfn7();
bool Vfn2();
bool Vfn4();
bool Vfn8();
bool Vfn1();
bool Vfn0();
bool Vfn13();
bool Vfn11();
bool Vfn12();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg4;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn10() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn15() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn6() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn7() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn4() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn8() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn5();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn1() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
Vfn5();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn0() {
uint jmp_to = 298u;
while (true) {
switch (jmp_to) {
case 298u:
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn1();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn8();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn13();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn13();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn5();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn10();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn13() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn11();
} else {
Vfn12();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn11() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn12() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, F7F353595E097416
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
lut_offset = lighting_lut_offset[1][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.g = lut_scale_rg * lut_value;
lut_offset = lighting_lut_offset[1][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.b = lut_scale_rb * lut_value;
lut_offset = lighting_lut_offset[0][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(view.xyz)), 0.0));
specular_sum.a = lut_scale_fr * lut_value;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((const_color[0].rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor0.rgb), (texcolor0.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp(mix((last_tev_out.a), (texcolor0.a), (texcolor0.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_2 = ByteRound(clamp((secondary_fragment_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((secondary_fragment_color.a) + (primary_fragment_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (texcolor1.rrr), (rounded_primary_color.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((secondary_fragment_color.a) * (const_color[3].a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((last_tev_out.rgb), (combiner_buffer.rgb), (last_tev_out.aaa)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((last_tev_out.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 4.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor0.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor1.g), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 7283F7A24885EC91
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 56DCF3B4D441DBA0, B76F238318D8A515
// reference: 5C15A45646D1A8B1, F7F353595E097416
// reference: 8F2058D727863594, 7283F7A24885EC91
// program: B76F238318D8A515, 0000000000000000, F7F353595E097416
// program: 0E8203CAEF38E823, 0000000000000000, 7283F7A24885EC91
// shader: 8B30, 08A1D7DC3576E512
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 73C7DF3A659650BF
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 045CD0E127863594, 08A1D7DC3576E512
// reference: 49D69AC327863594, 73C7DF3A659650BF
// reference: C2AA12F527863594, 573BCB23558CC9FD
// program: 0E8203CAEF38E823, 0000000000000000, 08A1D7DC3576E512
// program: 0E8203CAEF38E823, 0000000000000000, 73C7DF3A659650BF
// shader: 8B30, FEB58AD433889B2A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 9EAA6D8A79244259
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 5537D22D55D606FE

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn6();
bool Vfn12();
bool Vfn17();
bool Vfn3();
bool Vfn4();
bool Vfn5();
bool Vfn1();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn6() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn3() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn4();
} else {
Vfn5();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn5() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn1() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 170u;
while (true) {
switch (jmp_to) {
case 170u:
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn6();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn3();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn1();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn3();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn3();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn6();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn1();
Vfn3();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn3();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn1();
Vfn7();
Vfn3();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, 7C0B6207B2B52717
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (const_color[0].a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 634C925E99E6841F, FEB58AD433889B2A
// reference: 56677BBFE6EC7BFB, 9EAA6D8A79244259
// reference: 56DCF3B48D630208, 5537D22D55D606FE
// reference: A889D4615C1665E4, 7C0B6207B2B52717
// program: 6E0865F19FA8EB0E, 0000000000000000, FEB58AD433889B2A
// program: AEA50A5BCE37F791, 0000000000000000, 9EAA6D8A79244259
// program: 5537D22D55D606FE, 0000000000000000, 7C0B6207B2B52717
// shader: 8B30, C3932613B8B6242E
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 65EC91F427863594, 73C7DF3A659650BF
// reference: 4CC923F0BC2DC8E9, C3932613B8B6242E
// program: 9B4E66B7A24A26D1, 0000000000000000, C3932613B8B6242E
// shader: 8B30, 1DD5A4C88DB74C25
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 05BCB2B05D028A21
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 47F7434C4A6DD781, 1DD5A4C88DB74C25
// reference: 72DCAAAD35672865, 05BCB2B05D028A21
// program: 6E0865F19FA8EB0E, 0000000000000000, 1DD5A4C88DB74C25
// program: AEA50A5BCE37F791, 0000000000000000, 05BCB2B05D028A21
// shader: 8B30, 13AD96A807C9D37D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.g) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (combiner_buffer.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) * (texcolor0.g), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor2.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor2.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp((const_color[4].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 060390F5EC6BA344
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 47F7434CCDC259B1, 13AD96A807C9D37D
// reference: 72DCAAADB2C8A655, 060390F5EC6BA344
// program: 6E0865F19FA8EB0E, 0000000000000000, 13AD96A807C9D37D
// program: AEA50A5BCE37F791, 0000000000000000, 060390F5EC6BA344
// shader: 8B30, DFD53E648796F413
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, D7E8A10879D39967
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 98B1DD85ACE0ACC8
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 549991A791C03996
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 2ABFEE7F2EFFD432
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5B4B8E8D6EDCDBBF
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 76B35CC9324445E3
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 1BC8458C6CFC93AE
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 0CDEE3FE14074136, DFD53E648796F413
// reference: 07B9CA7AE6FA9BE8, D7E8A10879D39967
// reference: 30E0FC2B703211D0, 98B1DD85ACE0ACC8
// reference: B0DB814B22C3EA81, 549991A791C03996
// reference: 06F8C86F0C7E216F, 2ABFEE7F2EFFD432
// reference: E7D5CC2DED925AD0, 5B4B8E8D6EDCDBBF
// reference: D0A26B91C5A25807, 76B35CC9324445E3
// reference: 2FC205396ADBE7EA, 1BC8458C6CFC93AE
// program: 0E8203CAEF38E823, 0000000000000000, DFD53E648796F413
// program: 0E8203CAEF38E823, 0000000000000000, D7E8A10879D39967
// program: 0E8203CAEF38E823, 0000000000000000, 98B1DD85ACE0ACC8
// program: 1A4F97107F3846B4, 0000000000000000, 549991A791C03996
// program: A7DFDB0325399CC8, 0000000000000000, 2ABFEE7F2EFFD432
// program: 9B4E66B7A24A26D1, 0000000000000000, 5B4B8E8D6EDCDBBF
// program: 0E8203CAEF38E823, 0000000000000000, 76B35CC9324445E3
// program: 0E8203CAEF38E823, 0000000000000000, 1BC8458C6CFC93AE
// shader: 8B30, FD0DBD7909F98CC1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((const_color[3].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((const_color[3].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(fma((combiner_buffer.rgb), (primary_fragment_color.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B31, 229318A481F4F552

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn12();
bool Vfn17();
bool Vfn5();
bool Vfn6();
bool Vfn7();
bool Vfn2();
bool Vfn4();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn6();
} else {
Vfn7();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn6() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn7() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn4() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 184u;
while (true) {
switch (jmp_to) {
case 184u:
Vfn1();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn4();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn5();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn4();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn5();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn5();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn5();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn5();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
Vfn5();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn5();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn5();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
Vfn5();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, EDFB66F0D33733E7
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 1BC8458CB02BAE41
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, EA62592B9C3D84AC
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((const_color[3].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((const_color[3].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(fma((combiner_buffer.rgb), (primary_fragment_color.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 416DAE8D4B05D5AA, FD0DBD7909F98CC1
// reference: 56DCF3B4C6EED361, 229318A481F4F552
// reference: EE9019C201BD5489, EDFB66F0D33733E7
// reference: 2FC20539CF39818C, 1BC8458CB02BAE41
// reference: 5D09611AAC52A1DE, EA62592B9C3D84AC
// program: DEC4F585F5D29D43, 0000000000000000, FD0DBD7909F98CC1
// program: 229318A481F4F552, 0000000000000000, EDFB66F0D33733E7
// program: 0E8203CAEF38E823, 0000000000000000, 1BC8458CB02BAE41
// program: DEC4F585F5D29D43, 0000000000000000, EA62592B9C3D84AC
// shader: 8B31, 32134D5EFA3C6154

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

layout(binding=4, std140) uniform vs_config {
bool b[16];
uvec4 i[4];
vec4 f[96];
}vs_pica;
bool ExecVS();
layout(location=0) in vec4 vs_in_reg0;
vec4 vs_out_reg0;
layout(location=1) in vec4 vs_in_reg1;
vec4 vs_out_reg1;
layout(location=2) in vec4 vs_in_reg2;
vec4 vs_out_reg2;
layout(location=3) in vec4 vs_in_reg3;
vec4 vs_out_reg3;
layout(location=4) in vec4 vs_in_reg4;
vec4 vs_out_reg4;
layout(location=5) in vec4 vs_in_reg5;
vec4 vs_out_reg5;
layout(location=0) out vec4 primary_color;
layout(location=1) out vec4 texcoord0;
layout(location=2) out vec4 texcoord12;
layout(location=3) out vec4 normquat;
layout(location=4) out vec4 view;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};
void EmitVtx() {
vec4 vtx_pos = vec4(vs_out_reg0.x,vs_out_reg0.y,vs_out_reg0.z,vs_out_reg0.w);
gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
gl_ClipDistance[0] = -vtx_pos.z;
gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif
normquat = vec4(vs_out_reg1.x,vs_out_reg1.y,vs_out_reg1.z,vs_out_reg1.w);
vec4 vtx_color = vec4(vs_out_reg2.x,vs_out_reg2.y,vs_out_reg2.z,vs_out_reg2.w);
primary_color = clamp(vtx_color,vec4(0),vec4(1));
texcoord0 = vec4(vs_out_reg3.x,vs_out_reg3.y,vs_out_reg3.w,1);
texcoord12 = vec4(vs_out_reg5.x,vs_out_reg5.y,vs_out_reg5.z,vs_out_reg5.w);
view = vec4(vs_out_reg4.x,vs_out_reg4.y,vs_out_reg4.z,1);
}
void main() {
vs_out_reg0 = vec4(0, 0, 0, 1);
vs_out_reg1 = vec4(0, 0, 0, 1);
vs_out_reg2 = vec4(0, 0, 0, 1);
vs_out_reg3 = vec4(0, 0, 0, 1);
vs_out_reg4 = vec4(0, 0, 0, 1);
vs_out_reg5 = vec4(0, 0, 0, 1);
ExecVS();
EmitVtx();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
bool Vfn1();
bool Vfn12();
bool Vfn17();
bool Vfn4();
bool Vfn5();
bool Vfn6();
bool Vfn2();
bool Vfn7();
bool Vfn9();
bool Vfn0();
bool Vfn11();
bool Vfn10();
bool Vfn15();
bool Vfn13();
bool Vfn14();
vec4 tmp_reg0;
vec4 tmp_reg1;
vec4 tmp_reg2;
vec4 tmp_reg3;
vec4 tmp_reg4;
vec4 tmp_reg5;
vec4 tmp_reg6;
vec4 tmp_reg7;
vec4 tmp_reg8;
vec4 tmp_reg9;
vec4 tmp_reg10;
vec4 tmp_reg11;
vec4 tmp_reg12;
vec4 tmp_reg13;
vec4 tmp_reg14;
vec4 tmp_reg15;
bool ExecVS() {
tmp_reg0 = vec4(0, 0, 0, 1);
tmp_reg1 = vec4(0, 0, 0, 1);
tmp_reg2 = vec4(0, 0, 0, 1);
tmp_reg3 = vec4(0, 0, 0, 1);
tmp_reg4 = vec4(0, 0, 0, 1);
tmp_reg5 = vec4(0, 0, 0, 1);
tmp_reg6 = vec4(0, 0, 0, 1);
tmp_reg7 = vec4(0, 0, 0, 1);
tmp_reg8 = vec4(0, 0, 0, 1);
tmp_reg9 = vec4(0, 0, 0, 1);
tmp_reg10 = vec4(0, 0, 0, 1);
tmp_reg11 = vec4(0, 0, 0, 1);
tmp_reg12 = vec4(0, 0, 0, 1);
tmp_reg13 = vec4(0, 0, 0, 1);
tmp_reg14 = vec4(0, 0, 0, 1);
tmp_reg15 = vec4(0, 0, 0, 1);
Vfn0();
return true;
}

bool Vfn1() {
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
return false;
}
bool Vfn12() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn17() {
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
vs_out_reg4 = -tmp_reg9;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn4() {
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
if (!bool_regs.x) {
Vfn5();
} else {
Vfn6();
}
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
return false;
}
bool Vfn5() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn6() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
bool Vfn2() {
addr_regs.x = (ivec2(tmp_reg8.xx)).x;
tmp_reg8.z = dot_s(vs_pica.f[10 + addr_regs.x], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9 + addr_regs.x], vs_in_reg0);
tmp_reg8.x = dot_s(vs_pica.f[8 + addr_regs.x], vs_in_reg0);
tmp_reg8.w = (vs_pica.f[93].yyyy).w;
tmp_reg7.z = dot_3(vs_pica.f[10 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg7.x = dot_3(vs_pica.f[8 + addr_regs.x].xyz, tmp_reg12.xyz);
tmp_reg9.z = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[6]);
tmp_reg9.y = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[5]);
tmp_reg9.x = dot_s(vec4(tmp_reg8.xyz, 1.0), vs_pica.f[4]);
tmp_reg9.w = (vs_pica.f[93].yyyy).w;
tmp_reg12.x = dot_3(tmp_reg7.xyz, tmp_reg7.xyz);
tmp_reg13.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[3]);
tmp_reg10.z = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[2]);
tmp_reg10.y = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[1]);
tmp_reg10.x = dot_s(vec4(tmp_reg9.xyz, 1.0), vs_pica.f[0]);
tmp_reg13.xy = (mul_s(vs_pica.f[93].zyyy, -tmp_reg13.zzzz)).xy;
tmp_reg12.x = rsq_s(tmp_reg12.x);
vs_out_reg4 = -tmp_reg9;
bool_regs.x = tmp_reg10.xxxx.x < tmp_reg13.xyyy.x;
bool_regs.y = tmp_reg10.xxxx.y > tmp_reg13.xyyy.y;
tmp_reg10.w = (tmp_reg13.zzzz).w;
if (all(bool_regs)) {
tmp_reg10.x = (-tmp_reg13.zzzz).x;
}
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12.xxxx);
vs_out_reg0 = tmp_reg10;
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
return false;
}
bool Vfn7() {
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn9() {
tmp_reg15 = max_s(vs_pica.f[93].xxxx, tmp_reg12);
tmp_reg14 = max_s(vs_pica.f[93].xxxx, -tmp_reg12);
tmp_reg15 = mul_s(tmp_reg15, tmp_reg15);
tmp_reg14 = mul_s(tmp_reg14, tmp_reg14);
tmp_reg13.xyz = (mul_s(vs_pica.f[88], tmp_reg15.zzzz)).xyz;
tmp_reg12.xyz = (mul_s(vs_pica.f[89], tmp_reg14.zzzz)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.xxxx, vs_pica.f[84], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.xxxx, vs_pica.f[85], tmp_reg12)).xyz;
tmp_reg13.xyz = (fma_s(tmp_reg15.yyyy, vs_pica.f[86], tmp_reg13)).xyz;
tmp_reg12.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[87], tmp_reg12)).xyz;
return false;
}
bool Vfn0() {
uint jmp_to = 145u;
while (true) {
switch (jmp_to) {
case 145u:
Vfn1();
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg1);
if (vs_pica.b[14]) {
jmp_to = 494u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (vs_in_reg1).xyz;
vs_out_reg5.xy = (vs_pica.f[93].xxxx).xy;
if (vs_pica.b[14]) {
jmp_to = 500u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = vs_pica.f[93].yyyy;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
Vfn1();
vs_out_reg3.xyz = (vs_in_reg1).xyz;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[80], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[81], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[82], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2.xyyy)).xy;
if (vs_pica.b[0]) {
tmp_reg15.x = (vs_pica.f[4].wwww).x;
tmp_reg14.y = (vs_pica.f[5].wwww).y;
tmp_reg13.z = (vs_pica.f[6].wwww).z;
tmp_reg6.xyz = (mul_s(vs_pica.f[4].xyzz, tmp_reg15.xxxx)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg14.yyyy, vs_pica.f[5].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg6.xyz = (fma_s(tmp_reg13.zzzz, vs_pica.f[6].xyzz, tmp_reg6.xyzz)).xyz;
tmp_reg12 = tmp_reg8 + tmp_reg6;
tmp_reg13.x = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg13.y = rsq_s(tmp_reg13.x);
tmp_reg4 = mul_s(tmp_reg12, -tmp_reg13.yyyy);
tmp_reg14.x = dot_3(tmp_reg4.xyz, tmp_reg7.xyz);
tmp_reg14.y = (mul_s(vs_pica.f[95].xxxx, tmp_reg14.xxxx)).y;
tmp_reg5 = fma_s(tmp_reg14.yyyy, tmp_reg7, -tmp_reg4);
tmp_reg12.xyz = (vs_pica.f[93].xxyy + tmp_reg5.xyzz).xyz;
tmp_reg12.w = dot_3(tmp_reg12.xyz, tmp_reg12.xyz);
tmp_reg14.z = rsq_s(tmp_reg12.w);
tmp_reg12.xy = (mul_s(tmp_reg5.xyzz, tmp_reg14.zzzz)).xy;
tmp_reg13 = vs_pica.f[83];
}
vs_out_reg5.zw = (fma_s(tmp_reg12.xyxy, tmp_reg13.xzxz, tmp_reg13.ywyw)).zw;
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
Vfn7();
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
tmp_reg2 = tmp_reg12 + tmp_reg13;
Vfn4();
tmp_reg3 = -tmp_reg1 + tmp_reg2;
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyxy);
vs_out_reg2.xyz = (fma_s(tmp_reg3, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg1.xyz = (mul_s(vs_pica.f[68], tmp_reg0.xxxx)).xyz;
Vfn2();
tmp_reg1.xyz = (fma_s(tmp_reg0.yyyy, vs_pica.f[69], tmp_reg1)).xyz;
tmp_reg1.xyz = (fma_s(tmp_reg0.zzzz, vs_pica.f[70], tmp_reg1)).xyz;
Vfn4();
vs_out_reg3 = mul_s(vs_pica.f[95].yyyy, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[95].yyyy, vs_in_reg2.xyyy)).xy;
tmp_reg13 = mul_s(vs_pica.f[95].yyyy, vs_in_reg3);
tmp_reg14 = vs_pica.f[71];
tmp_reg13 = fma_s(tmp_reg13.yxxx, tmp_reg14.yxyx, tmp_reg14.wzwz);
tmp_reg12 = vec4(rcp_s(tmp_reg10.w));
tmp_reg12 = mul_s(tmp_reg10, tmp_reg12);
tmp_reg14 = vs_pica.f[72];
tmp_reg12 = fma_s(tmp_reg12, tmp_reg14.yxyx, tmp_reg14.wzwz);
vs_out_reg5.zw = (tmp_reg12.xyxy + tmp_reg13.xyxy).zw;
vs_out_reg2.xyz = (fma_s(-tmp_reg1, tmp_reg0.wwww, tmp_reg1)).xyz;
vs_out_reg2.w = (tmp_reg0.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn4();
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
Vfn10();
vs_out_reg2 = mul_s(vs_pica.f[95].zzzz, tmp_reg12);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn10();
tmp_reg2.x = (max_s(tmp_reg2.xxxx, tmp_reg2.yyyy)).x;
vs_out_reg2.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12)).xyz;
vs_out_reg2.w = (max_s(tmp_reg2.xxxx, tmp_reg2.zzzz)).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
vs_out_reg2.xyz = (mul_s(tmp_reg12, tmp_reg2)).xyz;
vs_out_reg2.w = (tmp_reg12.wwww).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
Vfn11();
tmp_reg13.xyz = (mul_s(vs_pica.f[95].zzzz, tmp_reg12.xyzz)).xyz;
vs_out_reg2.w = (tmp_reg2.xxxx).w;
vs_out_reg2.xyz = (fma_s(tmp_reg12.wwww, vs_pica.f[83].xyzz, tmp_reg13.xyzz)).xyz;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
Vfn7();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg2 = tmp_reg12 + tmp_reg13;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
Vfn15();
tmp_reg15 = mul_s(vs_pica.f[94].zzzz, vs_in_reg3);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg2 = fma_s(tmp_reg0.wwww, vs_pica.f[83], tmp_reg15);
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn15();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg2 = mul_s(vs_pica.f[83], tmp_reg0.wwww);
if (vs_pica.b[14]) {
jmp_to = 490u; break;
}
vs_out_reg0.x = dot_s(vs_pica.f[8], vs_in_reg0);
vs_out_reg0.y = dot_s(vs_pica.f[9], vs_in_reg0);
vs_out_reg0.z = dot_s(vs_pica.f[10], vs_in_reg0);
vs_out_reg0.w = dot_s(vs_pica.f[11], vs_in_reg0);
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg1);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg5.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
if (vs_pica.b[0]) {
tmp_reg0 = vs_pica.f[13];
tmp_reg12.xy = (fma_s(vs_in_reg3.wwww, vs_pica.f[12].xyyy, tmp_reg0.xyyy)).xy;
tmp_reg12.x = (max_s(vs_pica.f[94].wwww, tmp_reg12.xxxx)).x;
tmp_reg12.x = log2(tmp_reg12.x);
tmp_reg12.x = (fma_s(tmp_reg12.xxxx, vs_pica.f[12].zzzz, tmp_reg0.zzzz)).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.y = (min_s(vs_pica.f[93].yyyy, tmp_reg12.yyyy)).y;
tmp_reg8.z = (fma_s(tmp_reg12.xxxx, tmp_reg12.yyyy, tmp_reg8.zzzz)).z;
}
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
Vfn17();
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xyz;
vs_out_reg5.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg3);
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn1();
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg2);
vs_out_reg3.xyz = (mul_s(vs_pica.f[94].xxxx, vs_in_reg1)).xyz;
if (vs_pica.b[14]) {
jmp_to = 488u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
Vfn2();
Vfn4();
tmp_reg0.x = (vs_pica.f[83].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[84].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[85].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[86].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[83].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[84].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[85].xyz, tmp_reg1.xyz);
vs_out_reg5.yzw = vec3(dot_3(vs_pica.f[86].xyz, tmp_reg1.xyz));
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg4);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
tmp_reg0.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg2)).xy;
tmp_reg1.xy = (mul_s(vs_pica.f[94].xxxx, vs_in_reg3)).xy;
vs_out_reg5.zw = (mul_s(vs_pica.f[94].xxxx, vs_in_reg4.xyxy)).zw;
tmp_reg0.x = (vs_pica.f[12].wwww + tmp_reg0.xxxx).x;
tmp_reg0.y = (vs_pica.f[13].wwww + tmp_reg0.yyyy).y;
tmp_reg1.x = (vs_pica.f[14].wwww + tmp_reg1.xxxx).x;
tmp_reg1.y = (vs_pica.f[15].wwww + tmp_reg1.yyyy).y;
tmp_reg0.z = (vs_pica.f[93].yyyy).z;
tmp_reg1.z = (vs_pica.f[93].yyyy).z;
vs_out_reg3.x = dot_3(vs_pica.f[12].xyz, tmp_reg0.xyz);
vs_out_reg3.yzw = vec3(dot_3(vs_pica.f[13].xyz, tmp_reg0.xyz));
vs_out_reg5.x = dot_3(vs_pica.f[14].xyz, tmp_reg1.xyz);
vs_out_reg5.y = dot_3(vs_pica.f[15].xyz, tmp_reg1.xyz);
vs_out_reg2 = mul_s(vs_pica.f[94].yyyy, vs_in_reg5);
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
Vfn12();
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg3);
vs_out_reg2 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 504u; break;
}
vs_out_reg0 = vs_in_reg0;
vs_out_reg1 = vs_in_reg1;
vs_out_reg2 = vs_pica.f[93].yyyy;
vs_out_reg4 = vs_pica.f[93].xxxx;
if (vs_pica.b[14]) {
jmp_to = 496u; break;
}
tmp_reg9.z = dot_s(vec4(vs_in_reg0.xyz, 1.0), vs_pica.f[6]);
vs_out_reg0 = vs_in_reg0;
vs_out_reg3.yz = (vs_pica.f[93].xxxx).yz;
tmp_reg13.x = (-vs_pica.f[13].yyyy + -tmp_reg9.zzzz).x;
tmp_reg12.x = (vs_pica.f[93].yyyy + -tmp_reg13.xxxx).x;
tmp_reg12.xy = (max_s(vs_pica.f[93].xxxx, tmp_reg12.xyyy)).xy;
tmp_reg12.xy = (min_s(vs_pica.f[93].yyyy, tmp_reg12.xyyy)).xy;
vs_out_reg3.x = (tmp_reg12.xxxx).x;
if (vs_pica.b[14]) {
jmp_to = 487u; break;
}
vs_out_reg0 = vs_pica.f[93].xxxx;
vs_out_reg3.xyz = (vs_pica.f[93].xxxx).xyz;
case 487u:
vs_out_reg2 = vs_pica.f[93].xxxx;
case 488u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 490u:
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 494u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
case 496u:
vs_out_reg3 = vs_pica.f[93].xxxx;
vs_out_reg5 = vs_pica.f[93].xxxx;
return true;
case 500u:
vs_out_reg4 = vs_pica.f[93].xxxx;
vs_out_reg1 = vs_pica.f[93].xxxx;
vs_out_reg3.w = (vs_pica.f[93].xxxx).w;
vs_out_reg5.zw = (vs_pica.f[93].xxxx).zw;
case 504u:
return true;
default: return false;
}
}
return false;
}
bool Vfn11() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
tmp_reg13 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
Vfn4();
tmp_reg13 = vec4(rsq_s(tmp_reg13.x));
tmp_reg12.x = dot_3(vs_pica.f[90].xyz, tmp_reg7.xyz);
tmp_reg12.y = dot_3(vs_pica.f[91].xyz, tmp_reg7.xyz);
tmp_reg12.z = dot_3(vs_pica.f[92].xyz, tmp_reg7.xyz);
tmp_reg0 = mul_s(tmp_reg9, tmp_reg13);
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
tmp_reg1 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
Vfn9();
tmp_reg15 = abs(tmp_reg1);
tmp_reg14.w = (mul_s(vs_pica.f[82].wwww, tmp_reg15.wwww)).w;
tmp_reg14.w = (min_s(vs_pica.f[93].yyyy, tmp_reg14.wwww)).w;
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
tmp_reg12.w = (vs_pica.f[93].yyyy + -tmp_reg14.wwww).w;
tmp_reg12.w = (mul_s(vs_pica.f[83].wwww, tmp_reg12.wwww)).w;
return false;
}
bool Vfn10() {
tmp_reg8.x = (vs_in_reg1.wwww).x;
tmp_reg12 = mul_s(vs_pica.f[93].wwwy, vs_in_reg1);
Vfn2();
Vfn7();
Vfn4();
tmp_reg12.xyz = (tmp_reg12.xyzz + tmp_reg13.xyzz).xyz;
vs_out_reg3 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
vs_out_reg5 = mul_s(vs_pica.f[94].xxxx, vs_in_reg2);
return false;
}
bool Vfn15() {
tmp_reg12 = mul_s(vs_pica.f[93].wwww, vs_in_reg1);
tmp_reg8.x = dot_s(vs_pica.f[8], vs_in_reg0);
tmp_reg8.y = dot_s(vs_pica.f[9], vs_in_reg0);
tmp_reg8.z = dot_s(vs_pica.f[10], vs_in_reg0);
tmp_reg8.w = dot_s(vs_pica.f[11], vs_in_reg0);
tmp_reg7.x = dot_3(vs_pica.f[8].xyz, tmp_reg12.xyz);
tmp_reg7.y = dot_3(vs_pica.f[9].xyz, tmp_reg12.xyz);
tmp_reg7.z = dot_3(vs_pica.f[10].xyz, tmp_reg12.xyz);
tmp_reg9.x = dot_s(vs_pica.f[4], tmp_reg8);
tmp_reg9.y = dot_s(vs_pica.f[5], tmp_reg8);
tmp_reg9.z = dot_s(vs_pica.f[6], tmp_reg8);
tmp_reg9.w = (tmp_reg8.wwww).w;
tmp_reg12 = vec4(dot_3(tmp_reg7.xyz, tmp_reg7.xyz));
tmp_reg0 = vec4(dot_3(tmp_reg9.xyz, tmp_reg9.xyz));
tmp_reg12 = vec4(rsq_s(tmp_reg12.x));
tmp_reg0 = vec4(rsq_s(tmp_reg0.x));
vs_out_reg4 = -tmp_reg9;
tmp_reg7 = mul_s(tmp_reg7, tmp_reg12);
tmp_reg11.w = (vs_pica.f[93].xxxx).w;
tmp_reg0 = mul_s(tmp_reg9, tmp_reg0);
tmp_reg11.x = dot_3(vs_pica.f[4].xyz, tmp_reg7.xyz);
tmp_reg11.y = dot_3(vs_pica.f[5].xyz, tmp_reg7.xyz);
tmp_reg11.z = dot_3(vs_pica.f[6].xyz, tmp_reg7.xyz);
vs_out_reg0.x = dot_s(vs_pica.f[0], tmp_reg9);
vs_out_reg0.y = dot_s(vs_pica.f[1], tmp_reg9);
vs_out_reg0.z = dot_s(vs_pica.f[2], tmp_reg9);
vs_out_reg0.w = dot_s(vs_pica.f[3], tmp_reg9);
tmp_reg0 = vec4(dot_3(tmp_reg0.xyz, tmp_reg11.xyz));
tmp_reg14 = vs_pica.f[93].yyyy + tmp_reg11.zzzz;
tmp_reg15 = mul_s(vs_pica.f[95].zzzz, tmp_reg11);
bool_regs = equal(-vs_pica.f[93].yy, tmp_reg11.zz);
tmp_reg14 = mul_s(vs_pica.f[95].zzzz, tmp_reg14);
tmp_reg0 = abs(tmp_reg0);
tmp_reg14 = vec4(rsq_s(tmp_reg14.x));
tmp_reg0.w = (mul_s(vs_pica.f[82].wwww, tmp_reg0.wwww)).w;
if (!bool_regs.x) {
Vfn13();
} else {
Vfn14();
}
tmp_reg0.w = (min_s(vs_pica.f[93].yyyy, tmp_reg0.wwww)).w;
vs_out_reg1.w = (vs_pica.f[93].xxxx).w;
tmp_reg0.w = (vs_pica.f[93].yyyy + -tmp_reg0.wwww).w;
tmp_reg0.w = (mul_s(vs_pica.f[83].wwww, tmp_reg0.wwww)).w;
return false;
}
bool Vfn13() {
vs_out_reg1.z = rcp_s(tmp_reg14.x);
vs_out_reg1.xy = (mul_s(tmp_reg15, tmp_reg14)).xy;
return false;
}
bool Vfn14() {
vs_out_reg1.xyz = (vs_pica.f[93].yxxx).xyz;
return false;
}
// shader: 8B30, E71222D1FEB155E4
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 56DCF3B403572AD3, 32134D5EFA3C6154
// reference: 2F2104FF04DEF67B, 40065C472AE4DC56
// reference: 1A745F28B1E52750, E71222D1FEB155E4
// program: 32134D5EFA3C6154, 0000000000000000, 11B7D438BFF9AA08
// program: 0E8203CAEF38E823, 0000000000000000, E71222D1FEB155E4
// shader: 8B30, 32139D3BFD2611EB
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 111376ACE6FA9BE8, 32139D3BFD2611EB
// program: 0E8203CAEF38E823, 0000000000000000, 32139D3BFD2611EB
// shader: 8B30, 1B92B325337A8BDB
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: B872CB50E8E6D069, 1B92B325337A8BDB
// program: FB0C4ECF15CBE1EB, 0000000000000000, 8CC7FC6389010AC6
// program: DEC4F585F5D29D43, 0000000000000000, 1B92B325337A8BDB
// shader: 8B30, DADDF54C227C0BD1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 050273398796F413
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 2C86F1CE5DB3B58B
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, C854D8FCA096E6A2
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 42FC47322EA4A29C
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 0FBAE38E0B596747
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[3].rgb), (const_color[3].aaa)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[4].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = (combiner_buffer.rgb);
float alpha_output_5 = ByteRound(clamp((last_tev_out.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, CE165CB4DBD98EE3
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 65651EDB4AFF230D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((const_color[3].rgb) + (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((const_color[3].a) + (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = ByteRound(clamp(fma((combiner_buffer.rgb), (primary_fragment_color.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tev_out.a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 8EB3E4D3375F82D9, DADDF54C227C0BD1
// reference: 0CDEE3FEB1E52750, 050273398796F413
// reference: 7B40FB9514DEBBD8, 2C86F1CE5DB3B58B
// reference: CD63B2B13A637036, C854D8FCA096E6A2
// reference: 2CB570ABCBBE1386, 42FC47322EA4A29C
// reference: 584C1682DCA2A2A4, 0FBAE38E0B596747
// reference: 2C4EB6F307A27893, CE165CB4DBD98EE3
// reference: 8AF6D4537D1884F3, 65651EDB4AFF230D
// program: 0E8203CAEF38E823, 0000000000000000, DADDF54C227C0BD1
// program: 0E8203CAEF38E823, 0000000000000000, 050273398796F413
// program: 1A4F97107F3846B4, 0000000000000000, 2C86F1CE5DB3B58B
// program: A7DFDB0325399CC8, 0000000000000000, C854D8FCA096E6A2
// program: DEC4F585F5D29D43, 0000000000000000, 42FC47322EA4A29C
// program: DEC4F585F5D29D43, 0000000000000000, 0FBAE38E0B596747
// program: 9B4E66B7A24A26D1, 0000000000000000, CE165CB4DBD98EE3
// program: DEC4F585F5D29D43, 0000000000000000, 65651EDB4AFF230D
// shader: 8B30, 06C4FD9946B1172B
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 0FE8956B014D5C40
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 85D4CD57C5A25807, 06C4FD9946B1172B
// reference: DBC54215375F82D9, 0FE8956B014D5C40
// program: 0E8203CAEF38E823, 0000000000000000, 06C4FD9946B1172B
// program: 0E8203CAEF38E823, 0000000000000000, 0FE8956B014D5C40
// shader: 8B30, 9B23CC935851AADA
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 31098B36375F82D9, 9B23CC935851AADA
// program: 0E8203CAEF38E823, 0000000000000000, 9B23CC935851AADA
// shader: 8B30, 6CA5A24211B4675A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, AFE44C23B2BABF06
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 3A6EA2B2C5A25807, 6CA5A24211B4675A
// reference: C50ECC1A6ADBE7EA, AFE44C23B2BABF06
// program: 0E8203CAEF38E823, 0000000000000000, 6CA5A24211B4675A
// program: 0E8203CAEF38E823, 0000000000000000, AFE44C23B2BABF06
// shader: 8B30, 069C8C0A61CE5C7C
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 045CD0E101BD5489, 069C8C0A61CE5C7C
// program: 229318A481F4F552, 0000000000000000, 069C8C0A61CE5C7C
// shader: 8B30, C97614902136428C
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: FBB103BABC2DC8E9, C97614902136428C
// program: 9B4E66B7A24A26D1, 0000000000000000, C97614902136428C
// shader: 8B30, 7FC3AFB6A9B53932
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 940C4A8BDE517BFC
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 8D6D610C498B9A1A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 69C33FA22966623D, 7FC3AFB6A9B53932
// reference: DFE0768607DBA9D3, 940C4A8BDE517BFC
// reference: 3ECD72C450DF3421, 8D6D610C498B9A1A
// program: 1A4F97107F3846B4, 0000000000000000, 7FC3AFB6A9B53932
// program: A7DFDB0325399CC8, 0000000000000000, 940C4A8BDE517BFC
// program: 9B4E66B7A24A26D1, 0000000000000000, 8D6D610C498B9A1A
// shader: 8B30, 98EE978E5ED0F444
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 6A1DC949283D4D3D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, B4B7F4CB02184264
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 646806B6169F6195
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[2][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][1];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][3];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: DFE0768687CAC8E2, 98EE978E5ED0F444
// reference: 69C33FA2A977030C, 6A1DC949283D4D3D
// reference: 3ECD72C4D0CE5510, B4B7F4CB02184264
// reference: 4CA8399FA825D922, B4170363C2A69641
// reference: 3B5B2C050A7ACA68, 646806B6169F6195
// program: A7DFDB0325399CC8, 0000000000000000, 98EE978E5ED0F444
// program: 1A4F97107F3846B4, 0000000000000000, 6A1DC949283D4D3D
// program: 9B4E66B7A24A26D1, 0000000000000000, B4B7F4CB02184264
// program: A7DFDB0325399CC8, 0000000000000000, 646806B6169F6195
// reference: D4D5B6DB01BD5489, 6DF7980F844EA1EE
// shader: 8B30, 765C4E23FE631BC6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 32941422DD8534EC
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 9D44BBCBC710FA2B
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: F0B8960BB1E52750, 765C4E23FE631BC6
// reference: FBDFBF8FE6FA9BE8, 32941422DD8534EC
// reference: C5EDCDDC04DEF67B, 9D44BBCBC710FA2B
// program: 0E8203CAEF38E823, 0000000000000000, 765C4E23FE631BC6
// program: 0E8203CAEF38E823, 0000000000000000, 32941422DD8534EC
// program: 0E8203CAEF38E823, 0000000000000000, 9D44BBCBC710FA2B
// shader: 8B30, 049F5639227C0BD1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 8EB3E4D392BDE4BF, 049F5639227C0BD1
// program: 0E8203CAEF38E823, 0000000000000000, 049F5639227C0BD1
// shader: 8B30, 5E19726A8C5F077F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 375CCEA4563D73B3
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 5DA2CEECDDA6BAD3
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 3EB56F8DA8AF547B, 5E19726A8C5F077F
// reference: 889626A986129F95, 375CCEA4563D73B3
// reference: 8ABC1594D1160267, 5DA2CEECDDA6BAD3
// program: 1A4F97107F3846B4, 0000000000000000, 5E19726A8C5F077F
// program: A7DFDB0325399CC8, 0000000000000000, 375CCEA4563D73B3
// program: 9B4E66B7A24A26D1, 0000000000000000, 5DA2CEECDDA6BAD3
// shader: 8B30, C16AF02437CCEA50
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 647F2DF0375F82D9, C16AF02437CCEA50
// program: 0E8203CAEF38E823, 0000000000000000, C16AF02437CCEA50
// shader: 8B30, A3886868156024F6
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 1E9940708B7D1ACD, A3886868156024F6
// program: 32134D5EFA3C6154, 0000000000000000, A3886868156024F6
// shader: 8B30, 4633A47B0C648F70
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 6F180474C5A25807, 4633A47B0C648F70
// program: 0E8203CAEF38E823, 0000000000000000, 4633A47B0C648F70
// shader: 8B30, AFC67CA411093BC2
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 0B4429439B4F560F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 49BE0E1376F06BC9
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 79C225DAABEFC0D0, AFC67CA411093BC2
// reference: 3D297D9BE6FA9BE8, 0B4429439B4F560F
// reference: 364E541FB1E52750, 49BE0E1376F06BC9
// program: A7DFDB0325399CC8, 0000000000000000, AFC67CA411093BC2
// program: 0E8203CAEF38E823, 0000000000000000, 0B4429439B4F560F
// program: 0E8203CAEF38E823, 0000000000000000, 49BE0E1376F06BC9
// shader: 8B30, 698E5EEC75E62C2B
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) + (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tev_out.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 3E197FF801BD5489, 698E5EEC75E62C2B
// program: 96167D0382BE1967, 0000000000000000, A3886868156024F6
// program: 8B8D18415A8569F1, 0000000000000000, 698E5EEC75E62C2B
// shader: 8B30, 5AC8A8636D727862
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, D6D3F93D4A178C2F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, FF455D685B7C0B97
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[3].position + view.xyz);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view.xyz) + light_src[3].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[3].specular_0) + (refl_value * light_src[3].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.r) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((combiner_buffer.a) * (const_color[2].a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((texcolor0.rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((texcolor0.a), (last_tev_out.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_4 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp(fma((rounded_primary_color.a), (texcolor0.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 2.0, alpha_output_4 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_5 = ByteRound(clamp(mix((last_tev_out.rgb), (texcolor2.rgb), (texcolor1.ggg)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp((const_color[5].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 20DBEAFCBC27828C, 5AC8A8636D727862
// reference: 96F8A3D8929A4962, D6D3F93D4A178C2F
// reference: ED6195F0C59ED490, FF455D685B7C0B97
// program: 1A4F97107F3846B4, 0000000000000000, 5AC8A8636D727862
// program: A7DFDB0325399CC8, 0000000000000000, D6D3F93D4A178C2F
// program: 9B4E66B7A24A26D1, 0000000000000000, FF455D685B7C0B97
// shader: 8B30, A42EF55D878EA0EF
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 73DC3657D2BF1231
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 79B4738070866A6A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 56B0460E4F65625E
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, E770AFCFB807176D
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.r) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.aaa), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 76B35CC9B3CA3A06
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 4F762638BD9FF25F
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: F7FF4922375F82D9, A42EF55D878EA0EF
// reference: 65A6EA4D4CB8B4A4, 73DC3657D2BF1231
// reference: C102D56F5AAA2DCE, 79B4738070866A6A
// reference: 6FB2D7A0C0AE3A77, 56B0460E4F65625E
// reference: 03F80E0E6ADBE7EA, E770AFCFB807176D
// reference: D0A26B9160403E61, 76B35CC9B3CA3A06
// reference: FC9860A6C5A25807, 4F762638BD9FF25F
// program: 0E8203CAEF38E823, 0000000000000000, A42EF55D878EA0EF
// program: A7DFDB0325399CC8, 0000000000000000, 73DC3657D2BF1231
// program: 1A4F97107F3846B4, 0000000000000000, 79B4738070866A6A
// program: E4CCF1A640E89D4B, 0000000000000000, 56B0460E4F65625E
// program: 0E8203CAEF38E823, 0000000000000000, E770AFCFB807176D
// program: 0E8203CAEF38E823, 0000000000000000, 76B35CC9B3CA3A06
// program: 0E8203CAEF38E823, 0000000000000000, 4F762638BD9FF25F
// shader: 8B30, 9BF72517C9573EFA
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tev_out.rgb);
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 2.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, ECEB26AB05A05E16
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view.xyz);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position - view.xyz) + light_src[0].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 2E653D191F9D8950
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp(fma((texcolor0.rgb), (const_color[0].rgb), (const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(fma((texcolor0.a), (const_color[0].a), (const_color[0].a)), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp(vec3(dot((last_tev_out.rgb) - vec3(0.5), (const_color[1].rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((last_tev_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = (last_tev_out.rgb);
float alpha_output_4 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tev_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_f, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tev_out.rgb = mix(fog_color.rgb, last_tev_out.rgb, fog_factor);
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: A289EFE4375F82D9, 9BF72517C9573EFA
// reference: AE3D90937AA5E5FD, ECEB26AB05A05E16
// reference: A9EEC660C5A25807, 2E653D191F9D8950
// program: 0E8203CAEF38E823, 0000000000000000, 9BF72517C9573EFA
// program: A7DFDB0325399CC8, 0000000000000000, ECEB26AB05A05E16
// program: 0E8203CAEF38E823, 0000000000000000, 2E653D191F9D8950
// shader: 8B30, FEA576B1A6034373
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[1].position + view.xyz);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position - view.xyz) + light_src[1].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[1].specular_0) + (refl_value * light_src[1].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[2].position + view.xyz);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[4][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view.xyz) + light_src[2].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[2].specular_0) + (refl_value * light_src[2].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp(min((secondary_fragment_color.r) + (secondary_fragment_color.g), 1.0) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((rounded_primary_color.aaa) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((rounded_primary_color.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp(fma((const_color[2].rgb), (last_tev_out.aaa), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((const_color[2].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((rounded_primary_color.rgb), (texcolor0.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = (last_tev_out.a);
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: EDF4C3BBE6EC7BFB, FEA576B1A6034373
// program: AEA50A5BCE37F791, 0000000000000000, FEA576B1A6034373
// shader: 8B30, 83C8623554F68CBE
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((const_color[0].aaa) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 5C4501A452AA3944, 83C8623554F68CBE
// program: F4B767110674F1C9, 0000000000000000, 83C8623554F68CBE
// shader: 8B30, 6655B21E5A4743CC
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 0D8B55FFF12ADF49
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
light_vector = normalize(light_src[5].position + view.xyz);
spot_dir = light_src[5].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][1];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[5].dist_atten_scale * length(-light_src[5].position - view.xyz) + light_src[5].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[5].diffuse * dot_product) + light_src[5].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[5].specular_0) + (refl_value * light_src[5].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[6].position + view.xyz);
spot_dir = light_src[6].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][2];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[6].dist_atten_scale * length(-light_src[6].position - view.xyz) + light_src[6].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[6].diffuse * dot_product) + light_src[6].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[6].specular_0) + (refl_value * light_src[6].specular_1)) * clamp_highlights * dist_value * 1.0;
light_vector = normalize(light_src[7].position + view.xyz);
spot_dir = light_src[7].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[5][3];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[7].dist_atten_scale * length(-light_src[7].position - view.xyz) + light_src[7].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[7].diffuse * dot_product) + light_src[7].ambient) * dist_value * 1.0;
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[7].specular_0) + (refl_value * light_src[7].specular_1)) * clamp_highlights * dist_value * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 583734A49D07B26A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, CA78374FDBBAB5A1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
if (gl_FragCoord.x < scissor_x1 || gl_FragCoord.y < scissor_y1 || gl_FragCoord.x >= scissor_x2 || gl_FragCoord.y >= scissor_y2) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((texcolor1.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((texcolor1.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tev_out.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_3 = ByteRound(clamp((last_tev_out.rgb) * (texcolor2.rgb), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp((last_tev_out.a) * (texcolor2.a), 0.0, 1.0));
last_tev_out = vec4(color_output_3 * 2.0, alpha_output_3 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp((last_tev_out.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 4FD12A1C3171D61A
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((rounded_primary_color.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((const_color[0].a) * (texcolor1.r), 0.0, 1.0));
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_2 = ByteRound(clamp((last_tev_out.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = (rounded_primary_color.a);
last_tev_out = vec4(color_output_2, alpha_output_2);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((last_tev_out.aaa), (const_color[3].rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((last_tev_out.a), (const_color[3].a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((texcolor1.rrr) * (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (const_color[4].a);
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = (last_tev_out.a);
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 78DA66429A6E9761
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord12.zw, GetLod(texcoord12.zw * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = ByteRound(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = ByteRound(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tev_out = vec4(color_output_0 * 2.0, alpha_output_0 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp((last_tev_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((last_tev_out.a) * (const_color[1].a), 0.0, 1.0));
last_tev_out = vec4(color_output_1, alpha_output_1);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = ByteRound(clamp((texcolor2.rgb) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = ByteRound(clamp((texcolor2.a) * (last_tev_out.a), 0.0, 1.0));
last_tev_out = vec4(color_output_2 * 2.0, alpha_output_2 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
vec3 color_output_3 = ByteRound(clamp(fma((primary_fragment_color.rgb), (combiner_buffer.rgb), (last_tev_out.rgb)), vec3(0), vec3(1)));
float alpha_output_3 = ByteRound(clamp(fma((primary_fragment_color.a), (combiner_buffer.a), (last_tev_out.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_3, alpha_output_3);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_4 = ByteRound(clamp((secondary_fragment_color.rgb) * (texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_4 = ByteRound(clamp((secondary_fragment_color.a) * (texcolor1.a), 0.0, 1.0));
last_tev_out = vec4(color_output_4, alpha_output_4);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = ByteRound(clamp(fma((last_tev_out.rgb), (const_color[5].rgb), (combiner_buffer.rgb)), vec3(0), vec3(1)));
float alpha_output_5 = ByteRound(clamp(fma((last_tev_out.a), (const_color[5].a), (combiner_buffer.a)), 0.0, 1.0));
last_tev_out = vec4(color_output_5, alpha_output_5);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// shader: 8B30, 0FACCB8E6135D2D1
layout(location=0) in vec4 primary_color;
layout(location=1) in vec4 texcoord0;
layout(location=2) in vec4 texcoord12;
layout(location=3) in vec4 normquat;
layout(location=4) in vec4 view;
out vec4 color;
layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_l;
layout(binding=4) uniform samplerBuffer tex_lut_f;
layout(binding=5) uniform samplerBuffer tex_lut_rg;
layout(binding=6) uniform samplerBuffer tex_lut_rgba;

layout(binding=0, std140) uniform common_data {
vec3 fog_color;
vec3 tex_lod_bias;
vec4 clip_coef;
vec4 blend_color;
vec4 tev_combiner_color;
vec4 const_color[6];
float scissor_x1;
float scissor_y1;
float scissor_x2;
float scissor_y2;
float alphatest_ref;
float depth_scale;
float depth_offset;
float shadow_bias_constant;
float shadow_bias_linear;
int shadow_texture_bias;
int fog_lut_offset;
};

struct LightSrc {
vec3 specular_0;
vec3 specular_1;
vec3 diffuse;
vec3 ambient;
vec3 position;
vec3 spot_direction;
float dist_atten_bias;
float dist_atten_scale;
};
layout(binding=1, std140) uniform light_data0 {
LightSrc light_src[8];
};
layout(binding=2, std140) uniform light_data1 {
ivec4 lighting_lut_offset[6];
vec3 lighting_global_ambient;
float lut_scale_d0;
float lut_scale_d1;
float lut_scale_sp;
float lut_scale_fr;
float lut_scale_rb;
float lut_scale_rg;
float lut_scale_rr;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LightingLUTUnsigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}
float LightingLUTSigned(int lut_offset, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    vec2 entry = texelFetch(tex_lut_l, lut_offset + index).rg;
    return entry.r + entry.g * delta;
}

float ByteRound(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 ByteRound(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 ByteRound(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float GetLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = ByteRound(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0.xy, GetLod(texcoord0.xy * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord12.xy, GetLod(texcoord12.xy * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
int lut_offset = 0;
float lut_value = 1.0;
float d0_value = 1.0;
float d1_value = 1.0;
float dist_value = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[4].position + view.xyz);
spot_dir = light_src[4].spot_direction;
half_vector = normalize(view.xyz) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
lut_offset = lighting_lut_offset[1][2];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
refl_value.r = lut_scale_rr * lut_value;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
lut_offset = lighting_lut_offset[3][0];
lut_value = LightingLUTUnsigned(lut_offset, max(dot(light_vector, spot_dir), 0.0));
lut_offset = lighting_lut_offset[5][0];
dist_value = LightingLUTUnsigned(lut_offset, clamp(light_src[4].dist_atten_scale * length(-light_src[4].position - view.xyz) + light_src[4].dist_atten_bias, 0.0, 1.0));
lut_offset = lighting_lut_offset[0][0];
d0_value = LightingLUTUnsigned(lut_offset, max(dot(normal, normalize(half_vector)), 0.0));
diffuse_sum.rgb += ((light_src[4].diffuse * dot_product) + light_src[4].ambient) * dist_value * (lut_scale_sp * lut_value);
specular_sum.rgb += (((lut_scale_d0 * d0_value) * light_src[4].specular_0) + (refl_value * light_src[4].specular_1)) * clamp_highlights * dist_value * (lut_scale_sp * lut_value);
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_color;
vec4 last_tev_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tev_out = vec4(color_output_0, alpha_output_0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
vec3 color_output_1 = ByteRound(clamp(min((primary_fragment_color.rgb) + (texcolor1.rgb), vec3(1)) * (last_tev_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = ByteRound(clamp((const_color[1].a) * (texcolor0.a), 0.0, 1.0));
last_tev_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tev_out = clamp(last_tev_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tev_out.rgb;
next_combiner_buffer.a = last_tev_out.a;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = ByteRound(last_tev_out);
}
// reference: 1A9C07F8C87196F4, 6655B21E5A4743CC
// reference: ACBF4EDCE6CC5D1A, 0D8B55FFF12ADF49
// reference: 18A32D7E3129B1B1, 583734A49D07B26A
// reference: 26706AF4F5A9E4E1, CA78374FDBBAB5A1
// reference: 7C4B705EA4734676, 4FD12A1C3171D61A
// reference: CA68397A8ACE8D98, 78DA66429A6E9761
// reference: 64D83BB510CA9A21, 0FACCB8E6135D2D1
// program: A7DFDB0325399CC8, 0000000000000000, 6655B21E5A4743CC
// program: 1A4F97107F3846B4, 0000000000000000, 0D8B55FFF12ADF49
// program: 1A4F97107F3846B4, 0000000000000000, 583734A49D07B26A
// program: 6C2653B3E1A8C2B7, 0000000000000000, CA78374FDBBAB5A1
// program: A7DFDB0325399CC8, 0000000000000000, 4FD12A1C3171D61A
// program: 1A4F97107F3846B4, 0000000000000000, 78DA66429A6E9761
// program: E4CCF1A640E89D4B, 0000000000000000, 0FACCB8E6135D2D1
// reference: 609232A8A825D922, B4170363C2A69641
// reference: 40120D2022E59766, E9B93E0E5F120E63
